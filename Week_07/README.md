# 第7周学习总结

#### 字典树和并查集

二叉搜索树：

  根结点 大于左子树的所有结点； 根结点小于右子树所有结点；

  中序遍历是升序



字典树：Trie树，单词查找树或者键树，是一种树形结构

应用：统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计

优点：最大限度的减少所谓的字符串比较，查询效率比哈希表高



Trie树不是一颗二叉树，是一颗多叉树

基本性质：

1.结点本身不会存完整单词

2.从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串

3.每个结点的所有子结点路径代表的字符都不相同



核心思想：

 空间换时间

 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。



实现trie树，最重要的是 要熟悉Trie树的结构，它是一颗多叉树，每个结点都包含26个字母对应的下一个结点或者为nil



并查集：

适用场景：组团、配对问题； group or not？



基本操作：

1.makeset：建立一个新的并查集，其中包含s个单元素集合

2.unionSet(x,y)： 把元素x和元素y所在的集合合并，要求x和y所在集合不相交，如果相交，则不合并。

3.find(x)：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。



代码模版：

class UnionFind {

​	private var count: Int = 0

​	private var parent: [Int] = []



​	init(_ n: Int) {

​		self.count = n

​		parent = Array(repeating:0, count: n)

​		for i in 0..<n {

​			parent[i] = i

​		}

​	}



​	func find(_ p: Int) {

​		while p != parent[p] { // 领头元素就是它自己，现在是在找领头元素

​			parent[p] = parent[parent[p]] // 这里不太明白，为什么要这样赋值？

​			p = parent[p]

​		}

​		return p

​	}

​	

​	func union(_ p: Int, _ q: Int) {

​		let rootP: Int = find(p)

​		let rootQ: Int = find(q)

​		if rootP == rootQ { return }

​		parent[rootP] = rootQ

​		count -= 1

​	}

}





#### 高级搜索： 剪枝、双向BFS、启发式搜索（A*）

初级搜索：

1.朴素搜索

2.优化方式：不重复（fibonacci）、剪枝（生成括号问题）

3.搜索方向： DFS 深度优先搜索 ； BFS 广度优先搜索



 双向搜索、启发式搜索



利用数形结合思想



剪枝：去掉无效状态

回溯法：采用试错思想，它尝试分步的去解决一个问题，在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至上几步的计算，再通过其他的可能的分步解答再次尝试寻找问题的答案。

回溯法 通常用最简单的递归方法来实现，在反复重复上述步骤后可能出现两种情况：1.找到一个可能存在的正确的答案；2在尝试了所有可能的分步方法后宣告该问题没有答案

最坏的情况下，回溯法会导致一次时间复杂度指数时间的计算