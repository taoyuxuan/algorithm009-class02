# 算法学习 毕业总结



  为期两个月的算法学习结束了，但是算法对于自己来说确是刚刚起步。

  这两个月，我坚持在leetcode上的每日一题，走出了第一步。但也仅仅走出了第一步，是远远不够的。好习惯的养成、知识的丰富、以及知识的系统化！

  在训练营了，看到了那些特别努力和优秀的人！接下来要努力向他们看齐。

  

  先对这两个月的知识做个总结：

##### 数据结构：

  一维数据结构：

  数组  查询时间复杂度 O(1)  插入/删除时间复杂度 O(n)



  链表  查询时间复杂度 O(n)  插入/删除时间复杂度 O(1)

​       单链表  

​       双向链表 添加了指向前向结点的指针

​       循环链表：单向循环链表 + 双向循环链表   添加了指向头结点的指针

​       静态链表：用数组实现的链表；用游标替代指针指示结点在数组中的相对位置； 插入删除操作时无须移动元素，仅修改游标即可



  跳表  查询的时间复杂度O(logn)  插入删除的平均复杂度也为O(logn)  空间复杂度 O(n)

​       原理和实现简单 可以替代平衡叉树搜索树AVL  

​       应用 Redis LevelDB

​        

  栈   后进先出 出栈入栈时间复杂度 O(1) 

​       常见题型： 十进制和其他进制数转换、括号匹配、迷宫求解、表达式求值、利用2栈实现队列



  队列  先进先出  出队入队时间复杂度 O(1)

​       双端队列 入口和出口都可以入队和出队

​       常见题型： 滑动窗口、BFS、先进先出排队系列、利用2队列实现栈



  优先级队列  插入操作 O(1) // 这里为什么是O(1)  抽象的PriorityQueue 插入时间复杂度是O(1) 利用非波拉契堆；具体到语言里java是二叉堆实现，时间复杂度为O(logn)

​             取出操作 O(logn) 按优先级进行取出的

​			底层具体实现的数据结构较为多样和复杂： heap、BST(二叉搜索树) 、平衡二叉树查找树 AVL 红黑树

​             PriorityQueue是一种抽象数据结构，底层可以很多不同的实现



   循环队列  front == rear 队头等于队尾 代表是否队空 front-rear == 1 队满



  二维数据结构：

  哈希表 查询/插入/删除的时间复杂度 O(1)

​         最坏情况下 都是 O(n) 但这样就失去了散列表的意义  

​           处理 hash 冲突：

​              开放定址法：线性探测再散列、二次探测再散列、伪随机探测再散列

​              链表法 ： 将冲突的元素放到一个链表里

​              再哈希法：冲突后利用一个其他的哈希函数再进行定址

​              建立公共溢出区



  树  链表是特殊化的树；树是特殊化的图

​      遍历： 前序 中序 后序

​      一般用递归，因为没有办法有效的进行循环，但是递归非常简洁

 

​      二叉搜索树 

​       定义： 又名 有序二叉树、二叉排序树、二叉查找树

​       左子树上的所有结点的值均小于它根结点的值

​       右子树上的所有结点的值均大于它的根结点的值

​       以此类推，左右子树也分别为二叉搜索树 （重复性）  

​       它的中序遍历是升序

​      常见的二叉搜索树: AVL 2-3树  AVL  B-tree  Red-black tree 

​        

​	   时间复杂度： 插入、删除、查询  时间复杂度都是 O(logn)

​       最坏时间复杂度 O(n)  就是形成一个链表的时候

​	   **误区：判断是否为二叉搜索树，只判断左孩子和右孩子结点的大小，而忽略了左孩子的孩子和右孩子的孩子结点**



  堆

​      定义：可以迅速找到一堆数中的最大值或者最小值的数据结构

​       heap堆事抽象数据结构，并不是二叉堆，二叉堆和其他堆只是堆的实现

​       大顶堆/小顶堆 

​       常见操作: 获取最大值/最小值 O(1) 

​                删除最大值/最小值 O(logn)

​                插入 O(logn) 或者 O(1) 斐波那契堆

​       堆的种类：二叉堆 

​                多项式堆

​                斐波那契堆

​                严格斐波那契堆

​                2-3堆

​        二叉堆：

​           比较慢的堆，实现的效率并不高，但是实现简单

​           二叉堆 通过完全二叉树来实现（注意并不是二叉搜索树）

​           二叉堆事 优先队列的一种完全二叉树，一般用一维数组来表示



  图

​     属性： V-vertex 顶点 1.出度和入度 2点与点之间，连通与否

​           E-edge 边：1有向无向 2权重（边长）

​     分类：无向有权图、有向有权图

​     图的表示：临接表、邻接矩阵

​     基于图的相关算法：DFS、BFS

​        图的遍历一定要有visited状态表，树不需要是因为树不存在环





AVL 

​    1.平衡二叉搜索树

​    2.每个结点存 balance factor = {-1, 0, 1}

​    3.四种旋转操作 左旋 右旋  左右旋 右左旋  以及 带子树情况的左右旋



​    不足：结点需要存储额外信息、且调整次数频繁



​    为什么要有AVL？  因为它的查询、插入、删除操作都是 O(logn)的时间复杂度

​     AVL树是为了方便快速查询而来的，它的查找时间复杂度为O(logn)

​    平衡因子是怎么定的？  

​     平衡因子的由来，它的时间复杂度是等于树的深度的，它会记录深度差，要保证深度差不能超过 1

​    平衡因子 不平衡的时候要怎么办？

​     需要4中旋转操作：左旋 右旋  左右旋 右左旋



红黑树   近似平衡二叉搜索树

​    性质： 它能确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树：

​     1.每个结点要么是红色、要么是黑色

​     2.根结点是黑色

​     3.每个叶结点（nil结点，空结点）是黑色的

​     4.不能有相邻接的两个红色结点

​     5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点



​    维护 旋转的频次变低了



​    关键性质：

​       从根到叶子结点的最长可能路径不多于最短的可能路径的两倍长





AVL 和红黑树的对比

​      1.AVL trees 相比于红黑树 在查询方面是更快速的

​      2.红黑树相比于AVL tree在插入和删除操作方面是更快速的

​      3.AVL tree 的每个结点都存储了平衡因子或者高度 是int类型，而红黑树每个结点只需要1个bit来存储红和黑，AVL tree需要更多的存储空间

​      4.红黑树常用于语言的底层库 比如 map multimap multisetin C++

​         AVL tree 常用于数据库，数据库更多的是查询操作

​         java c++的 map set 都是用红黑树实现

​      5.插入和查询操作一半一半的话 一般是用红黑树，因为红黑树比较简洁 比较好实现





布隆过滤器 

​      定义：一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

​      优点：空间效率和查询的时间都远远超过一般的算法

​      缺点：有一定的误识别率和删除困难。





##### 算法思想：

  递归  



  分治  将问题分解成多个子问题；分别解决子问题，然后再合并问题



  回溯  解决一个回溯问题，实际上就是一个决策树的遍历过程



  DFS、BFS  一般用于树和图的遍历



  贪心算法  一种在每一步选择中都采取在当前状态下最好或者最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法



  动态规划  分治+最优子结构

​     动态规划关键点：

​      1.最优子结构： opt[n]=best_of(opt[n-1], opt[n-2],…)

​      2.存储中间状态: opt[i] 

​      3.递推公式（美其名曰：状态转移方程或者dp方程）

​         Fib: opt[i] = opt[n-1]+opt[n-2]

​         二维路径： opt[i,j] = opt[i+1][j]+opt[i][j+1]（且判断a[i,j]是否为空）



​    dp 三部曲：

​       1.最优子结构

​       2.状态定义

​       3.递推公式

 

##### 思维要点：

 1.不要进行人肉递归 

 2.寻找最近重复性

 3.利用数学归纳法



##### 解题四件套：

 1.看清题目，将自己理解的题解的意思跟面试官沟通清楚，是否是自己理解的那样

 2.想所有可能的解法，比较各种解法。 进行比较时间空间复杂度，找出最优解

 3.写代码  采用自顶向下的编程方法 先把大体思路写出来，然后再丰富细节

 4.想测试用例，然后测试自己的代码



##### 五毒神掌：

  1.看解法，找出最优最简洁的解法。 背诵+抄写

  2.第二遍记住以后，自己默写一遍

  3.第三遍 12小时以后 再默写一遍

  4.第四遍 一周以后 再默写一遍

  5.第五遍 头面试前，再看一遍并默写

