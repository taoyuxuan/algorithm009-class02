

# 第8周学习总结

### 位运算 + 算数移位与逻辑移位 

为什么需要位运算？

  机器里的数字表示方式和存储格式就是二进制



  十进制和二进制转换



位运算： 箭头指向哪边，就是向哪边移

  左移 << 

  右移 >> 

  按位或  ｜  只要有1个为1，结果就是1

  按位与  &  只要有1个为0， 结果就是0

  按位取反 ~ 0变1 1变0

  按位异或  ^ 相同为0 相异为 1



异或高级操作：

   相同为0 不同为1 也可用 不进位加法 来理解



   异或操作的特点：

   x^0 = x    // 0位还为0 1位异或0 还是1

   x^1 = ~x   // 1s 意思是 全 1

   x^(~x) = 1

   x^x = 0

   c = a^b  => a^c=b, b^c = a

   a^b^c = a^(b^c) = (a^b)^c

   

指定位置的位运算

  \1. 将x的最右边的n位清零  x&(~0<<n)

  2.获取 x的第n位值 （0或者1): (x>>n)&1

  3.获取x的第n位的幂值: x&(1<<n)

  4.仅将第n位置位1： x|(1<<n)

  5.仅将第n位置位0: x&(~(1<<n))

  6.将x最高位至第n位（包含）清零: x&((1<<n)-1)



实战位运算要点：

1.判断奇偶  

   x%2 == 1 =>  x&1 == 1

   x%2 == 0 => x&1 == 0

2.x>>1 => x/2

  x = x/2

3.x = x&(x-1)清零最低位的1

4.x&-x =>得到最低位的1

5.x&~x = 0



知识补漏：

  1.二进制中的原码、反码、补码

​    对于有符号数而言：

​    1).二进制的最高位是符号位：0表示正数，1表示负数

​    2).正数的原码、反码、补码都一样

​    3).负数的反码 = 它的原码符号位不变，其他位取反

​    4).负数的补码 = 它的反码 + 1

​    5).0的反码、补码 都是 0

​    6).在计算机运算的时候，都是以补码的方式来运算的！！！！ 所以在对负数进行二进制运算时，用补码来算！

​    7).**如果想将 二进制 转为 十进制，必须使用 二进制的原码；**

   2.x&(-x) 的计算流程

​    如果 x = 0b0110 十进制为6, -x = 0b1001(原码)+1 = 0b1010 (补码)

​    那么 x & -x = 0b0110 & 0b1010 = 0b0010  

​    规律就是 得到最低位的1；

   延伸：

​    假如 x是 2的幂 => x的二进制 1的位数 只有1个1； 

​    x的负数 二进制形式是 反码+1。反码是除符号位 其他位取反，1的位变0了，其他位全为1。

​     然后补码=反码+1 也就是原来1的位的后面的1 全为0，1进位到原来1的位置，补码0位置变为1

​     然后 x&-x = 除了正数1的位置，其他位置全为0了，这时候 结果和x相等，

​     也就是结论： x为2的幂的时候， x&-x = x





# 布隆过滤器

 

一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

优点：空间效率和查询的时间都远远超过一般的算法

缺点：有一定的误识别率和删除困难。



应用：

  1.比特币网络

  2.分布式系统  Map-Reduce Hadoop searchEngine

  3.Redis缓存

  4.垃圾邮件、评论等的过滤





# 排序



初级排序：

  冒泡排序

  插入排序

  选择排序

高级排序：

  快速排序

  堆排序

  归并排序



非比较排序：

   计数排序

   桶排序

   基数排序

![img](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)



![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

